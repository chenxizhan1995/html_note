附录摘选
================================================================================

B. Element Prohibitions

    This appendix is normative.

    The following elements have prohibitions(禁令，禁律) on which elements they can contain (see SGML Exclusions). This prohibition applies to all depths of nesting, i.e. it contains all the descendant elements.

    a
        must not contain other a elements.
    pre
        must not contain the img, object, big, small, sub, or sup elements.
    button
        must not contain the input, select, textarea, label, button, form, fieldset, iframe or isindex elements.
    label
        must not contain other label elements.
    form
        must not contain other form elements.
================================================================================
C. HTML Compatibility Guidelines

    This appendix is informative.

    This appendix summarizes design guidelines for authors who wish their XHTML documents to render on existing HTML user agents. Note that this recommendation does not define how HTML conforming user agents should process HTML documents. Nor does it define the meaning of the Internet Media Type text/html. For these definitions, see [HTML4] and [RFC2854] respectively.

    C.1. Processing Instructions and the XML Declaration

    Be aware that processing instructions are rendered on some user agents. Also, some user agents interpret the XML declaration to mean that the document is unrecognized XML rather than HTML, and therefore may not render the document as expected. For compatibility with these types of legacy browsers, you may want to avoid using processing instructions and XML declarations. Remember, however, that when the XML declaration is not included in a document, the document can only use the default character encodings UTF-8 or UTF-16.

    C.2. Empty Elements

    Include a space before the trailing / and > of empty elements, e.g. <br />, <hr /> and <img src="karen.jpg" alt="Karen" />. Also, use the minimized tag syntax for empty elements, e.g. <br />, as the alternative syntax <br></br> allowed by XML gives uncertain results in many existing user agents.

    C.3. Element Minimization and Empty Element Content

    Given an empty instance of an element whose content model is not EMPTY (for example, an empty title or paragraph) do not use the minimized form (e.g. use <p> </p> and not <p />).

    C.4. Embedded Style Sheets and Scripts

    Use external style sheets if your style sheet uses < or & or ]]> or --. Use external scripts if your script uses < or & or ]]> or --. Note that XML parsers are permitted to silently remove the contents of comments. Therefore, the historical practice of "hiding" scripts and style sheets within "comments" to make the documents backward compatible is likely to not work as expected in XML-based user agents.

    C.5. Line Breaks within Attribute Values

    Avoid line breaks and multiple white space characters within attribute values. These are handled inconsistently by user agents.

    C.6. Isindex

    Don't include more than one isindex element in the document head. The isindex element is deprecated in favor of the input element.

    C.7. The lang and xml:lang Attributes

    Use both the lang and xml:lang attributes when specifying the language of an element. The value of the xml:lang attribute takes precedence.

    C.8. Fragment Identifiers

    In XML, URI-references [RFC2396] that end with fragment identifiers of the form "#foo" do not refer to elements with an attribute name="foo"; rather, they refer to elements with an attribute defined to be of type ID, e.g., the id attribute in HTML 4. Many existing HTML clients don't support the use of ID-type attributes in this way, so identical values may be supplied for both of these attributes to ensure maximum forward and backward compatibility (e.g., <a id="foo" name="foo">...</a>).

    Further, since the set of legal values for attributes of type ID is much smaller than for those of type CDATA, the type of the name attribute has been changed to NMTOKEN. This attribute is constrained such that it can only have the same values as type ID, or as the Name production in XML 1.0 Section 2.3, production 5. Unfortunately, this constraint cannot be expressed in the XHTML 1.0 DTDs. Because of this change, care must be taken when converting existing HTML documents. The values of these attributes must be unique within the document, valid, and any references to these fragment identifiers (both internal and external) must be updated should the values be changed during conversion.

    Note that the collection of legal values in XML 1.0 Section 2.3, production 5 is much larger than that permitted to be used in the ID and NAME types defined in HTML 4. When defining fragment identifiers to be backward-compatible, only strings matching the pattern [A-Za-z][A-Za-z0-9:_.-]* should be used. See Section 6.2 of [HTML4] for more information.

    Finally, note that XHTML 1.0 has deprecated the name attribute of the a, applet, form, frame, iframe, img, and map elements, and it will be removed from XHTML in subsequent versions.

    C.9. Character Encoding

    Historically, the character encoding of an HTML document is either specified by a web server via the charset parameter of the HTTP Content-Type header, or via a meta element in the document itself. In an XML document, the character encoding of the document is specified on the XML declaration (e.g., <?xml version="1.0" encoding="EUC-JP"?>). In order to portably present documents with specific character encodings, the best approach is to ensure that the web server provides the correct headers. If this is not possible, a document that wants to set its character encoding explicitly must include both the XML declaration an encoding declaration and a meta http-equiv statement (e.g., <meta http-equiv="Content-type" content="text/html; charset=EUC-JP" />). In XHTML-conforming user agents, the value of the encoding declaration of the XML declaration takes precedence.

    Note: be aware that if a document must include the character encoding declaration in a meta http-equiv statement, that document may always be interpreted by HTTP servers and/or user agents as being of the internet media type defined in that statement. If a document is to be served as multiple media types, the HTTP server must be used to set the encoding of the document.

    C.10. Boolean Attributes

    Some HTML user agents are unable to interpret boolean attributes when these appear in their full (non-minimized) form, as required by XML 1.0. Note this problem doesn't affect user agents compliant with HTML 4. The following attributes are involved: compact, nowrap, ismap, declare, noshade, checked, disabled, readonly, multiple, selected, noresize, defer.

    C.11. Document Object Model and XHTML

    The Document Object Model level 1 Recommendation [DOM] defines document object model interfaces for XML and HTML 4. The HTML 4 document object model specifies that HTML element and attribute names are returned in upper-case. The XML document object model specifies that element and attribute names are returned in the case they are specified. In XHTML 1.0, elements and attributes are specified in lower-case. This apparent difference can be addressed in two ways:

    User agents that access XHTML documents served as Internet media type text/html via the DOM can use the HTML DOM, and can rely upon element and attribute names being returned in upper-case from those interfaces.
    User agents that access XHTML documents served as Internet media types text/xml, application/xml, or application/xhtml+xml can also use the XML DOM. Elements and attributes will be returned in lower-case. Also, some XHTML elements may or may not appear in the object tree because they are optional in the content model (e.g. the tbody element within table). This occurs because in HTML 4 some elements were permitted to be minimized such that their start and end tags are both omitted (an SGML feature). This is not possible in XML. Rather than require document authors to insert extraneous elements, XHTML has made the elements optional. User agents need to adapt to this accordingly. For further information on this topic, see [DOM2]
    C.12. Using Ampersands in Attribute Values (and Elsewhere)

    In both SGML and XML, the ampersand character ("&") declares the beginning of an entity reference (e.g., &reg; for the registered trademark symbol "®"). Unfortunately, many HTML user agents have silently ignored incorrect usage of the ampersand character in HTML documents - treating ampersands that do not look like entity references as literal ampersands. XML-based user agents will not tolerate this incorrect usage, and any document that uses an ampersand incorrectly will not be "valid", and consequently will not conform to this specification. In order to ensure that documents are compatible with historical HTML user agents and XML-based user agents, ampersands used in a document that are to be treated as literal characters must be expressed themselves as an entity reference (e.g. "&amp;"). For example, when the href attribute of the a element refers to a CGI script that takes parameters, it must be expressed as http://my.site.dom/cgi-bin/myscript.pl?class=guest&amp;name=user rather than as http://my.site.dom/cgi-bin/myscript.pl?class=guest&name=user.

    C.13. Cascading Style Sheets (CSS) and XHTML

    The Cascading Style Sheets level 2 Recommendation [CSS2] defines style properties which are applied to the parse tree of the HTML or XML documents. Differences in parsing will produce different visual or aural results, depending on the selectors used. The following hints will reduce this effect for documents which are served without modification as both media types:

    CSS style sheets for XHTML should use lower case element and attribute names.
    In tables, the tbody element will be inferred by the parser of an HTML user agent, but not by the parser of an XML user agent. Therefore you should always explicitly add a tbody element if it is referred to in a CSS selector.
    Within the XHTML namespace, user agents are expected to recognize the "id" attribute as an attribute of type ID. Therefore, style sheets should be able to continue using the shorthand "#" selector syntax even if the user agent does not read the DTD.
    Within the XHTML namespace, user agents are expected to recognize the "class" attribute. Therefore, style sheets should be able to continue using the shorthand "." selector syntax.
    CSS defines different conformance rules for HTML and XML documents; be aware that the HTML rules apply to XHTML documents delivered as HTML and the XML rules apply to XHTML documents delivered as XML.
    C.14. Referencing Style Elements when serving as XML

    In HTML 4 and XHTML, the style element can be used to define document-internal style rules. In XML, an XML stylesheet declaration is used to define style rules. In order to be compatible with this convention, style elements should have their fragment identifier set using the id attribute, and an XML stylesheet declaration should reference this fragment. For example:

    <?xml-stylesheet href="http://www.w3.org/StyleSheets/TR/W3C-REC.css" type="text/css"?>
    <?xml-stylesheet href="#internalStyle" type="text/css"?>
    <!DOCTYPE html
         PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <title>An internal stylesheet example</title>
    <style type="text/css" id="internalStyle">
      code {
        color: green;
        font-family: monospace;
        font-weight: bold;
      }
    </style>
    </head>
    <body>
    <p>
      This is text that uses our
      <code>internal stylesheet</code>.
    </p>
    </body>
    </html>
    C.15. White Space Characters in HTML vs. XML

    Some characters that are legal in HTML documents, are illegal in XML document. For example, in HTML, the Formfeed character (U+000C) is treated as white space, in XHTML, due to XML's definition of characters, it is illegal.

    C.16. The Named Character Reference &apos;

    The named character reference &apos; (the apostrophe, U+0027) was introduced in XML 1.0 but does not appear in HTML. Authors should therefore use &#39; instead of &apos; to work as expected in HTML 4 user agents.

--------------------------------------------------------------------------------
建议在XHTML中使用Processing Instruction和xml声明。因为某些用户代理会认为带有XML声明的文档是XML文档而不是HTML文档，进而产生非预期的渲染效果，所以可以省略xml声明，但要注意，省略xml声明后，文档编码只能是默认的utf8和utf16中的一种；

空元素有两种格式比如，<br></br>和<br />,但推荐使用后者，因为前者在许多用户代理中会产生非预期效果。同时注意，后者元素名称和斜杠之间的空格是必要的。

如果样式表中使用了&或<或]]>或--字符，那么应该把它们放在外部链接文件中；
如果脚本代码中使用了&或<或]]>或--字符，那么应该把它们放在外部链接文件中；
XML处理器被允许无声无息地移除注释内容，故而，位于注释中的”隐藏“脚本虽然在html4中可以良好工作，但在基于xml的用户代理中则会失去效果。

避免在属性值内部使用换行和连续空白，因为不同的用户代理的处理效果不同。

建议同时使用mxl:lang和lang属性（前者具有更高的优先级）。


在xhtml中，只有id属性可以用作代码段的标识符，name不再具有此功能。为了最大限度的保持前向和后向兼容，可以同时使用id和name属性，但要注意，同一元素内这两个属性的值必须一致（这一点无法通过DTD强制约束，全靠开发者自觉遵守），另外，xhtml 1.0将 a, applet, form, frame, iframe, img, 和 map 元素的name属性标记为过时，这几个元素的name属性将会在后继版本的xhtml规范中移除。


字符编码
    最好的方式是html服务器在http头中设定html页面的编码，如果难以做到，可以在html文档内指定，但强烈建议同时使用xml声明和meta元素指定（在xhtml一致的用户代理中，xml声明中指定的字符编码具有更高的优先级）。

在SGML和XML中，&都标志着引用实体的开始。比如，&reg;代表符号®（圆圈里一个字符R）。html用户代理会容忍错误的&转义序列，并将它们当作字面字符理解，但基于xml的用户代理则不会容忍此类错误而是认为文档无效，为了保证一致性，在需要使用&字符的地方一定要用&apm;（&字符的引用实体表示形式）而不要直接使用&。比如，
元素a的href属性的值应该写作
    http://my.site.dom/cgi-bin/myscript.pl?class=guest&amp;name=user
而不是
    http://my.site.dom/cgi-bin/myscript.pl?class=guest&name=user.